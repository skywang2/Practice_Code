1.尝试在模板算法中调用greater<int>()这类function object（函数对象）
2.尝试实现一个函数对象
3.写一个用uint8_t xxx:1（位域长度）组成的结构体
4.函数形参传int数组指针
5.函数返回const引用
6.复制复杂链表
7.写一个使用位域的结构体
8.拷贝复杂链表
9.右值引用构造函数
10.使用stringstream实现一个类型转换的模板函数
11.重载class的强制类型转换符
12.查看catch变量引用和非引用的地址区别
13.People.h测试父类A中有virtual func()函数，子类B中重写func()，查看父类test()函数中调用func()具体调用哪个
14.测试strtok();
15.memmove()和memcpy()对比，memmove在dst串和src串在内存上有重叠时会保证dst得到完整复制
16.std::move()在移动构造函数上的应用
17.调用一个自己封装的dll
18.shared_ptr智能指针
19.看vector的范形式定义的左右边界
20.同行定义多个对象
21.friend关键字
22.构造一个带iterator的固定类型容器类
23.unique_ptr、move
24.使用fstream把二维数组写入文件，测试打开文件错误时的state
25.字符串分割
26.remove_reference简单使用
27.创建一个template类，并定义几个函数
28.调试智能指针
29.fstream获取文件大小（判空）
30.用throw抛出函数返回值
31.尝试使用allocator分配内存
32.引用方式传数组
33.查看new创建的对象生命周期是否超过大括号范围，new创建在堆上，生命周期为全局
34.vector保存指针，查看vector析构时是否会释放指针所指空间
35.继承单例类
36.使用stl哈希函数
- hash，查看std::transform的用法
- 深拷贝的拷贝构造函数
- 正则表达式分割字符串
- 装饰模式
37.设置exe与dll分目录，并设置dll延迟启动
38.ctime、iomanip输出格式化的日期时间
39.代理模式
40.工厂模式
41._snprintf，安全函数
42.使用sizeof计算不定长数组长度
43.观察int32给char[4]赋值后字节顺序，高高低低-小端序
44.局部类对象会在定义时初始化，使用默认构造
45.冒泡排序
46.测试map、vector遍历时删除元素
47.尝试使用std::remove
48.命令模式
49.职责链模式
50.中介者模式
51.popen函数
52.享元模式
53.std::bind
54.stl优先队列
55.负0的表示与计算
56.测试模板返回值是用auto，尾置返回->decltype(xxx)
57.右值引用参数
58.模板参数的转发
59.格式化字符串显示当前时间，c标准库函数
60.可变参数模板
61.测试UE中FString使用时要加*的原因，手动实现一个类似FString的类型
